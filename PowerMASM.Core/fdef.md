

# MicroASM `fdef` Function Export & C# Binding

This document describes the design of the `fdef` keyword in **PowerMASM** and how it integrates with the runtime to generate **C# delegate bindings** (similar to ANTLR4 in C#).

---

## 1. Motivation

MicroASM is primarily low-level and label-based, but higher-level applications often require calling MicroASM code from a host runtime (C#). The `fdef` keyword allows functions defined in `.pmasm` files to be:

1. Exported to the runtime environment.
2. Automatically exposed as C# delegates.
3. Callable from host applications as if they were regular C# methods.

---

## 2. Syntax

```
fdef <type> <name>(<args>) -> <return type>
    ; body
    RET
```

### Example

```asm
fdef int Add(int a, int b) -> int
    MOV RAX a
    ADD RAX b
    RET

fdef double Sqrt(double x) -> double
    MNI Math.sqrt x RAX
    RET
```

---

## 3. Compiler/Assembler Output

During compilation, `fdef` functions are emitted as **JSON descriptors** alongside their instructions.

### Example JSON

```json
{
  "Name": "Add",
  "Instructions": ["MOV RAX a", "ADD RAX b", "RET"],
  "Exported": true,
  "Signature": {
    "Parameters": [
      { "Name": "a", "Type": "int" },
      { "Name": "b", "Type": "int" }
    ],
    "ReturnType": "int"
  }
}
```

This information drives both runtime execution and C# binding generation.

---

## 4. Code Generation Step

A tool (e.g., `pmasmc --gen-csharp`) scans `.pmasm` files for `fdef` functions and generates C# classes with delegate definitions and runtime bindings.

### Example Generated Code

```csharp
// Auto-generated by PowerMASM codegen
using System;
using PowerMASM.Runtime;

namespace PowerMASM.Generated
{
    public static class MathBindings
    {
        public delegate int AddDelegate(int a, int b);
        public delegate double SqrtDelegate(double x);

        public static AddDelegate Add =
            RuntimeEnvironment.BindFunction<AddDelegate>("Add");

        public static SqrtDelegate Sqrt =
            RuntimeEnvironment.BindFunction<SqrtDelegate>("Sqrt");
    }
}
```

---

## 5. Runtime Binding API

The PowerMASM runtime provides a `BindFunction<TDelegate>(string name)` method that:

1. Locates the function JSON by name.
2. Creates a **trampoline** that marshals arguments into registers/stack.
3. Executes the MicroASM function.
4. Returns the result via `RAX`.
5. Wraps the trampoline in a C# delegate.

### Example Implementation

```csharp
public static class RuntimeEnvironment
{
    public static TDelegate BindFunction<TDelegate>(string name)
        where TDelegate : Delegate
    {
        var function = LoadedProgram.GetFunction(name);

        return (TDelegate)(object)(Delegate.CreateDelegate(
            typeof(TDelegate),
            new Func<int, int, int>((a, b) =>
            {
                var regs = new RegisterFile();
                regs.RDI = a;
                regs.RSI = b;

                function.Invoke(regs);

                return (int)regs.RAX;
            })));
    }
}
```

*(Note: Codegen can generate specialized trampolines for different signatures.)*

---

## 6. Usage in Host Applications

Once `.pmasm` is compiled and C# bindings are generated, host code can call exported functions directly:

```csharp
using PowerMASM.Generated;

class Program
{
    static void Main()
    {
        int result = MathBindings.Add(5, 7);
        Console.WriteLine(result); // 12

        double s = MathBindings.Sqrt(9.0);
        Console.WriteLine(s); // 3
    }
}
```

---

## 7. Integration with Object Orientation

If combined with future `classdef` support, `fdef` functions can be grouped into classes:

```asm
classdef Math
    fdef int Add(int a, int b) -> int
        MOV RAX a
        ADD RAX b
        RET
endclass
```

The generated binding would namespace functions as:

```json
"Name": "Math.Add"
```

And the generated C# binding would become:

```csharp
public static class MathBindings
{
    public delegate int AddDelegate(int a, int b);
    public static AddDelegate Add =
        RuntimeEnvironment.BindFunction<AddDelegate>("Math.Add");
}
```

---

## 8. Workflow Summary

1. Write `.pmasm` files with `fdef` functions.
2. Compile → JSON metadata & instructions.
3. Run codegen → C# delegate bindings.
4. Host application calls MicroASM functions like regular C# methods.

---

✅ Result: MicroASM becomes **seamlessly callable from C#**, while still preserving its low-level assembly roots.

---

